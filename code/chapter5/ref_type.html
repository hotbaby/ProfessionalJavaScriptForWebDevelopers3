<html>
    <head>
        <title>Javascript高级程序设计（第3版）</title>
    </head>

    <body>
        <h1>引用类型</h1>
        <p>引用类型的值（对象）是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。</p>
        <b>虽然引用类型与类看起来很类似，但它们是不同的概念。为避免混淆，本书不使用类这个概念。</b>

        <h2>Object类型</h2>
        <p>创建Object实例的方式有两种。</p>
        <p>第一种是使用new操作符后跟Object构造函数：</p>
        <script type="text/javascript">
            console.log("\n");
            console.log("new创建Object");
            var person = new Object();
            person.name = "Nicholas";
            person.age = 29;
        </script>
        
        <p>第二种方式是对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。</p>
        <script type="text/javascript">
            console.log("\n");
            console.log("字面常量创建Object");
            var person = {
                "name": "Nicholas",
                "age": 29
            };
        </script>

        <h2>Array类型</h2>
        <script type="text/javascript">
            var colors = new Array();
            var colors = new Array(3);
            var colors = new Array("red", "green", "blue");
            console.log(colors);

            var colors = ["red", "green", "blue"];
            console.log(colors);
        </script>

        <h3>检测数据</h3>
        <p>Array.isArray方法</p>
        <script type="text/javascript">
            var colors = ["red", "green", "blue"];
            console.log("Array.isArray检测数据：" + Array.isArray(colors));
        </script>

        <h3>转换方法</h3>
        <p>toLocaleString(), toString(), valueOf()</p>
        <script type="text/javascript">
            console.log("\n");
            console.log("转换方法");
            var colors = ["red", "green", "blue"];
            console.log(colors.toString());
            console.log(colors.toLocaleString());
            console.log(colors.valueOf());

            console.log(colors.join(','));
            console.log(typeof colors.join(','));
            console.log(colors.join('||'));
            console.log(typeof colors.join('||'));
        </script>

        <h3>栈方法</h3>
        <p>ECMAScript数组也提供了让一种数据的行为类似与其他数据结构的方法。具体来书，数组可以表现的像栈一样。</p>
        <p>push, pop方法</p>
        <script type="text/javascript">
            console.log("\n");
            console.log("栈方法：");
            var colors = new Array();
            colors.push("red", "green");
            console.log(colors);

            colors.push("blue");
            colors.pop();
            console.log(colors);
        </script>

        <h3>队列方法</h3>
        <p>unshift, shift方法</p>
        <script type="text/javascript">
            console.log("\n");
            console.log("队列方法");
            var colors = new Array();
            colors.push("red");
            colors.push("green");
            colors.push("blue");
            colors.shift();
            console.log(colors);

            var colors = [];
            colors.unshift("red", "green");
            colors.unshift("blue");
            colors.pop();
            console.log(colors);
        </script>

        <h3>重排序方法</h3>
        <p>sort, reverse方法</p>
        <script type="text/javascript">
            console.log("\n");
            console.log("重排序：");
            var values = [3, 4, 0, 10];
            console.log(values);

            values.sort();
            console.log(values);

            values.reverse();
            console.log(values);

            function compare(value1, value2) {
                if (value1 > value2) {
                    return 1;
                }
                else if (value1 == value2) {
                    return 0;
                }
                else {
                    return -1;
                }
            }
            values.sort(compare);
            console.log(values);
        </script>
        <h3>操作方法</h3>

        <h3>位置方法</h3>
        <p>indexOf, lastIndexOf方法</p>

        <h3>迭代方法</h3>
        <ol>
            <li>every(): 对数据的每一项运行给定的函数，如果函数对每一项都返回true, 则返回true</li>
            <li>filter(): 对数据每一项运行给定函数，返回函数返回true的项组成的数组</li>
            <li>forEach(): 对数组每一项运行给定函数，该函数没有返回值</li>
            <li>map(): 对数组每一项运行给定函数，返回每次调用结果组成的数组</li>
            <li>some(): 对数组每一项运行给定函数，如果函数的任一项放回true，则返回true</li>
        </ol>

        <h3>归并方法</h3>
        <p>reduce, reduceRight方法</p>


        <h2>Date类型</h2>
        <p>ECMAScript中的Date类型是在早期Java中的java.util.Date类型基础上构建的。为此，Date使用自1970.1.1开始经过的毫秒数来保存日期。</p>
        <script type="text/javascript">
            var now = new Date();
        </script>
        <h3>继承的方法</h3>
        <p>Date类型重写toLocaleString()、toString()和valueOf()方法，但这些方法返回的值与其他类型的方法不同。</p>
        <p>Date类型的toLocaleString()方法会按照浏览器设置地区响应的格式返回日期和时间。</p>

        <h3>日期格式化方法</h3>
        <ol>
            <li>toDateString()</li>
            <li>toTimeString()</li>
            <li>toLocaleDateString()</li>
            <li>toLocaleTimeString()</li>
            <li>toUTCString()</li>
        </ol>

        <h3>日期/时间组件方法</h3>
        <p></p>

        <h2>RegExp类型</h2>
        <p>ECMAScript通过RegExp类型来支持正则表达式。var expression = / pattern / flags;</p>
        <p>正则表达式支持的标志：</p>
        <ol>
            <li>g: 表示全局global模式，即模式用于所有的字符串，而非在发现第一个匹配项时停止</li>
            <li>i: 表示不区分大小case-insentitive模式，即在匹配时忽略与字符串的大小写</li>
            <li>m: 表示多行multiline模式</li>
        </ol>

        <h2>Function类型</h2>
        <p>每个函数都是Function类型的实例，而且与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上是指向函数对象的指针，不会与某个函数绑定。</p>
        <script type="text/javascript">
            function sum(num1, num2) {
                return num1 + num2;
            }

            var sum = function(num1, num2) {
                return num1 + num2;
            }
        </script>

        <h3>没有重载</h3>
        <h3>函数式生命与函数表达式</h3>
        <p>解析器在执行环境加载数据时，对函数式声明和函数表达式并非一视同仁。解析器会在率先读取函数声明，并使其在执行代码之前可用，至于函数表达式，必须要等到解析器执行到它躲在的代码行，才会真正解释执行。</p>
        <p>函数式声明:</p>
        <script type="text/javascript">
            // alert(sum(10, 10));
            function sum(num1, num2) {
                return num1 + num2;
            }
        </script>
        <p>以上代码正产执行</p>

        <p>函数表达式:</p>
        <script type="text/javascript">
            // alert(sum(10, 10));
            var sum = function(num1, num2) {
                return num1 + num2;
            }
        </script>
        <p>以上代码执行会报错</p>

        <h3>作为值的函数</h3>
        <h3>函数内部属性</h3>
        <p>在函数内部，有两个特殊的对象：arguments和this. 其中, arguments是一个数组对象，包含所有传入函数的参数。虽然arguments的作用是保存函数参数，但这个对象有一个callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</p>
        <script type="text/javascript">
            function factorial(num) {
                if (num <= 1) {
                    return 1
                }
                else{
                    return num * arguments.callee(num-1)
                }
            }
        </script>
        <p>函数内部的另一个对象是this。this引用的是函数据以执行的环境变量。当再网页全局作用域调用函数时，this引用的是window对象。</p>
        <h3>函数的属性和方法</h3>
        <p>ECMAScript中的函数时对象，因此函数也有属性和方法。每个函数都有两个属性：length和prototype。其中，length属性表示函数希望接收命名参数的个数。</p>
        <script type="text/javascript">
            function sum(num1, num2) {
                return num1 + num2;
            }
            console.log(sum.length);
        </script>
        <p>在ECMAScript核心定义的全部属性中，最耐人寻味的就是prototype属性了。对于ECMAScript的引用类型，prototype保存着所有实例方法的真正所在。诸如toString()和valueOf()等方法实际保存在prototype名下，只不过通过对象实例访问罢了。在自定义创建引用类型以及实现继承时，prototype属性都是极为重要的。在ECMAScript5中，prototype属性是不可枚举的，因此使用for-in无法实现。</p>
        <p>每个函数都包含两个非集成而来的方法：apply()和call()。apply()方法接收两个参数：一个是其运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。</p>
        <script type="text/javascript">
            function sum(num1, num2) {
                return num1 + num2;
            }

            function callSum1(num1, num2) {
                return sum.apply(this, arguments);
            }

            function callSum2(num1, num2) {
                return sum.apply(this, [num1, num2]);
            }
        </script>
        <p>callSum1()在执行sum()函数时，传入了this(因为是在全局的作用域中调用，所以传入的window对象)和arguments对象。 ？？？</p>
        <p>call()方法与apply()方法的作用相同，它们的区别在于接收参数的方式不同。</p>
        <script type="text/javascript">
            function sum(num1, num2) {
                return num1 + num2;
            }

            function callSum(num1, num2) {
                return sum.call(this, num1, num2);
            }
        </script>
        <p>事实上，传递参数并非apply()和call()真正的用武之地，它们真正强大的地方是能够扩充函数赖以运行的作用域。</p>
        <script type="text/javascript">
            window.color = "red";
            var o = {
                color: "blue",
            }

            function sayColor() {
                return this.color;
            }

            sayColor.apply(this);
            sayColor.apply(window);
            sayColor(o);
        </script>
        <p>ECMAScript 5 还定义了一个方法：bind()。这个方法会创建一个函数实例，其this会绑定到传递给bind()函数的值。</p>

        <h2>基本包装类型</h2>
        <p>为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用各类型：Boolean、Number和String。这些类型和本章介绍的其他引用类型相似。</p>
        <h3>Boolean类型</h3>
        <h3>Number类型</h3>
        <h3>String类型</h3>

        <h2>单体内置类型</h2>
        <p>ECMAScript-262对内置对象的定义是：“由ECMAScript实现提供的、不依赖与宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”意思是说，开发人员必须显式实例化内置对象，因为它们已经实例化。除了Object、Array和String，ECMAScript-262还定义了两个单体内置对象：Global和Math。</p>
        <h3>Global对象</h3>
        <h4>1. URI编码方法</h4>
        <p>Global对象的encodeURI()和encodeURIComponent()方法可以对URI进行编码，以便发给浏览器。有效的URI不能含有某些特殊字符，比如空格。</p>
        <p>URI方法encodeURI()、encodeURIComponent()、decodeURI()和decodeURIComponent()用于替代已经被ECMAScript-262第3版废弃的escape()和unescape()方法。</p>
        <h4>2. eval()方法</h4>
        <p>ECMAScript语言最强大一个方法：eval()。eval()方法就像一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript字符串。</p>
        <script type="text/javascript">
            eval("console.log('hello ECMAScript')");
        </script>
        <h4>3. Global对象属性</h4>
        <h4>4. window对象</h4>
        <p>ECMAScript虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成了window对象的属性。</p>
        <script type="text/javascript">
            var color = "red";
            function sayColor() {
                return window.color;
            }
            console.log(window.color);
            console.log(window.sayColor());
        </script>

        <h3>Math对象</h3>
        <p>ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。</p>
        <h4>1. Math对象属性</h4>
        <p></p>
        <h4>2. min()和max()方法</h4>
        <h4>舍入方法</h4>
        <p>下面来介绍将小数舍入为整数的几个方法：Math.ceil()、Math.floor()和Math.round()。</p>
        <ol>
            <li>Math.ceil()向上取整</li>
            <li>Math.floor()向下取整</li>
            <li>Math.round()四舍五入</li>
        </ol>

        <h4>4. random()方法</h4>
        <p>Math.random()返回大于等于0小于1的一个随机数。</p>
        <h4>5. 其他方法</h4>
        <table border="1">
            <tr>
                <th>方法</th>
                <th>说明</th>        
            </tr>
            <tr>
                <td>Math.abs(num)</td>
                <td>返回num的绝对值</td>    
            </tr>
            <tr>
                <td>Math.exp(num)</td>
                <td>返回Math.E的num次幂</td>
            </tr>
            <tr>
                <td>Math.log(num)</td>
                <td>返回num的自然对数</td>
            </tr>
            <tr>
                <td>Math.pow(num, power)</td>
                <td>返回num的power次幂</td>
            </tr>
            <tr>
                <td>Math.sqrt(num)</td>
                <td>返回num的平方根</td>
            </tr>
            <tr>
                <td>Math.acos(x)</td>
                <td>返回x的反余弦值</td>
            </tr>
            <tr>
                <td>Math.asin(x)</td>
                <td>返回x的反正弦值</td>
            </tr>
        </table>
        <h3>小结</h3>
        <ul>
            <li>引用类型和传统面向对象程序设计中类相似，但实现不同</li>
            <li>Object是一个基础类型，所有其他类型都从Object继承了基本的行为</li>
            <li>Array类型是一组值的有序列表，同时提供了操作和转化这些值的功能</li>
            <li>Date类型提供了日期和时间的信息，包括当前日期和时间以及相关的计算功能</li>
            <li>RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本和一些高级的正则表达式功能</li>
        </ul>
        <p>函数实际上是Function类的实例，因此函数也是对象；而这一点也是JavaScript最具特色的地方。由于函数也是对象，所以函数也有方法，可以用来增强其行为。</p>
        <p>因为有了基本包装类型，所有JavaScript基本类型可以被党委对象来访问。三种基本的包装类型分别是：Boolean、Number和String。以下是它们功能的特征：</p>
        <ul>
            <li>每个包装类型都映射到同名的基本类型</li>
            <li>在读取模式下，访问基本类型时，就会创建对应的基本包装类型的一个对象，从而方便数据操作</li>
            <li>操作基本类型的语句执行完毕，就会立即销毁创建的包装类型。</li>
        </ul>
        <p>在所有代码执行之前，作用域中已经存在了两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象，不过，Web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。Math对象提供了很多属性和方法，用于完成复杂数学计算任务。</p>
    </body>
</html>